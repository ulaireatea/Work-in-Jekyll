---
layout: post
title:  Tarefa 9
date:   2020-11-01 16:02:00 +0300
image:  t9.png
tags:   [MetCompLic]
---
**Conteúdo**
* TOC
{:toc}

# Descrição do movimento harmônico simples

Movimento massa-mola, é um sistema fisíco supondo uma mola ideal de constante elástica K, presa a um objeto de massa M.
A compressão desta mola gera uma energia potencial elástica que ao ser liberada é convertida em energia cinética.
Possui ao ser liberada uma força restauradora que devolve de maneira elástica a sua posição ao equilíbrio, o sistema é composto de um comprimento de alongamento X, uma amplitude de movimento A, um período T que é o tempo que ela percorre uma oscilação completa, a frequência de oscilação que é o número de oscilações por segundo, a velocidade angular W que indica a velocidade com a qual a mola oscila e sua fase (theta) que indica a ponto inicial onde o obejto oscilador inicia o seu trajeto oscilatório.

Usando a Lei de Hooke definida de sistema de força elástica:

$ F = -k.x $

Com esta equação definimos a força elástica do sistema usando os valores definidos em sua descrição da mola ideal.
Com a segunda lei de Newton abaixo conseguimos unir e chegarmos a um sistema.

2º lei de Newton:

$ F = m.\frac{d^2x}{dt^2} $

Compilando ambas equações, considerando as forças sendo a única e a mesma intereção e isolando a váriavel posição X, temos:

$ x(t)=A.cos(\sqrt{\frac{k}{m}}.t+\theta_{0}) $

Esta é a equação do movimento harmônico simples.

## Ilustração sistema massa-mola

![]({{site.baseurl}}/img/massamola.png)

### Entrada

```sh
# Biliotecas:
import numpy as np
import matplotlib.pyplot as plt


# Função:
def MHS(A, k, m, t, theta0):
    x = A * np.cos(np.sqrt(k / m) * t + theta0)
    return (x)


# valores definidos para simulação:
A = 0.5
k = 2.4
m = 0.35
t0 = 0
tf = 14
theta0 = 0

#Valores definidos no SI

# Plotagem do gráfico:
def MHSplot(A, k, m, t0, tf, theta0, N):
    t = np.linspace(t0, tf, N)
    x = MHS(A, k, m, t, theta0)
    plt.plot(t, x, color="green", label="Sistema Massa-Mola")
    plt.legend(loc='upper left')
    plt.xlabel("Eixo Temporal (s)")
    plt.ylabel("Eixo posicional (m)")
    plt.savefig("Graficomovimento.png")


MHSplot(A, k, m, t0, tf, theta0, 100)
```


### Saída - Plotagem do Gráfico do MHS

![]({{site.baseurl}}/img/Graficomovimento.png)

#### Curiosidades

Para o movimento harmônico amortecido, podemos usar a equação de Euler da mesma maneira como fizemos no python para o MHS.
Abaixo é possível ter uma idéia da relação de entre equação do método de Euler e o gráfico do movimento.

```sh
# Biliotecas utilizadas no Pycharm
import math

from PIL import ImageDraw, Image

# Ambiente gráfico
imgx = 900
imgy = 500
image = Image.new("RGB", (imgx, imgy))
draw = ImageDraw.Draw(image)


# Definição da equação de Euler utilizada para gerar simulação
def Euler2(f, xa, xb, ya, y1a, n):
    h = (xb - xa) / float(n)
    x = xa
    y = ya
    y1 = y1a
    for i in range(n):
        y1 += h * f(x, y, y1)
        y += h * y1
        x += h
    return [y, y1]


# Valores randomizados para execução da simulação
m = 2.0  # massa (kg)
F0 = 4.76  # Amplitude da força (N)
omega = 0.36  # frequencia angular (rad/s)
phi = 0.0  # constante de fase (rad)
b = 0.0  # constante de atrito (carater informativo apenas) (Ns/m)
k = 20.0  # constante da mola (N/m)


# Equação Euler para movimento amortecido massa mola
def f(x, y, y1):
    return (F0 * math.cos(omega * x - phi) - b * y1 - k * y) / m


# Posicional do gráfico
yaSim = 0.0  # posição inicial (m)
y1aSim = 0.0  # velocidade inicial (m/s)
n = 1000  # nº passos para Euler
xaSim = 0.0  # tempo inicial (s)
xbSim = 100.0  # tempo final (s)
xdSim = xbSim - xaSim  # deltaT
nSim = 1000  # nº passos simulação

# Máximos e minímos definidos para o gráfico
ya = yaSim
y1a = y1aSim
yMin = ya
yMax = ya
for i in range(nSim):
    xa = xaSim + xdSim * i / nSim
    xb = xaSim + xdSim * (i + 1) / nSim
    y_y1 = Euler2(f, xa, xb, ya, y1a, n)
    ya = y_y1[0]
    y1a = y_y1[1]
    if ya < yMin:
        yMin = ya
    if ya > yMax:
        yMax = ya

# Definição do Range com movimento simulado:
ya = yaSim
y1a = y1aSim
for i in range(nSim):
    xa = xaSim + xdSim * i / nSim
    xb = xaSim + xdSim * (i + 1) / nSim
    kxa = (imgx - 1) * (xa - xaSim) / xdSim
    kya = (imgy - 1) * (ya - yMin) / (yMax - yMin)
    y_y1 = Euler2(f, xa, xb, ya, y1a, n)
    ya = y_y1[0]
    y1a = y_y1[1]
    kxb = (imgx - 1) * (xb - xaSim) / xdSim
    kyb = (imgy - 1) * (ya - yMin) / (yMax - yMin)
    draw.line((kxa, kya, kxb, kyb), (0, 255, 0))  # (r, g, b)

image.save('Gráfico.png', "PNG")
```


![]({{site.baseurl}}/img/Gráfico.png)

